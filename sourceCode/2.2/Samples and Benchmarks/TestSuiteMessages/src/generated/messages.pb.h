// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace testsuitemessages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class LoginRequest;
class LoginResultResponse;
class EchoRequest;
class EchoResponse;
class RoutedMessageRequest;
class RoutedMessageResponse;
class GroupMessageRequest;
class GroupMessageResponse;
class SubscribeToBroadcastQueueRequest;
class BroadcastMessageRequest;
class BroadcastMessageResponse;
class MemTestRequest;
class MemTestResponse;

// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();
  
  LoginRequest(const LoginRequest& from);
  
  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();
  
  void Swap(LoginRequest* other);
  
  // implements Message ----------------------------------------------
  
  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string pseudo = 1;
  inline bool has_pseudo() const;
  inline void clear_pseudo();
  static const int kPseudoFieldNumber = 1;
  inline const ::std::string& pseudo() const;
  inline void set_pseudo(const ::std::string& value);
  inline void set_pseudo(const char* value);
  inline void set_pseudo(const char* value, size_t size);
  inline ::std::string* mutable_pseudo();
  inline ::std::string* release_pseudo();
  
  // optional bool claimPseudo = 2;
  inline bool has_claimpseudo() const;
  inline void clear_claimpseudo();
  static const int kClaimPseudoFieldNumber = 2;
  inline bool claimpseudo() const;
  inline void set_claimpseudo(bool value);
  
  // required string accessKey = 3;
  inline bool has_accesskey() const;
  inline void clear_accesskey();
  static const int kAccessKeyFieldNumber = 3;
  inline const ::std::string& accesskey() const;
  inline void set_accesskey(const ::std::string& value);
  inline void set_accesskey(const char* value);
  inline void set_accesskey(const char* value, size_t size);
  inline ::std::string* mutable_accesskey();
  inline ::std::string* release_accesskey();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.LoginRequest)
 private:
  inline void set_has_pseudo();
  inline void clear_has_pseudo();
  inline void set_has_claimpseudo();
  inline void clear_has_claimpseudo();
  inline void set_has_accesskey();
  inline void clear_has_accesskey();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pseudo_;
  ::std::string* accesskey_;
  bool claimpseudo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResultResponse : public ::google::protobuf::Message {
 public:
  LoginResultResponse();
  virtual ~LoginResultResponse();
  
  LoginResultResponse(const LoginResultResponse& from);
  
  inline LoginResultResponse& operator=(const LoginResultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResultResponse& default_instance();
  
  void Swap(LoginResultResponse* other);
  
  // implements Message ----------------------------------------------
  
  LoginResultResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResultResponse& from);
  void MergeFrom(const LoginResultResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool is_accepted = 1;
  inline bool has_is_accepted() const;
  inline void clear_is_accepted();
  static const int kIsAcceptedFieldNumber = 1;
  inline bool is_accepted() const;
  inline void set_is_accepted(bool value);
  
  // required string pseudo = 2;
  inline bool has_pseudo() const;
  inline void clear_pseudo();
  static const int kPseudoFieldNumber = 2;
  inline const ::std::string& pseudo() const;
  inline void set_pseudo(const ::std::string& value);
  inline void set_pseudo(const char* value);
  inline void set_pseudo(const char* value, size_t size);
  inline ::std::string* mutable_pseudo();
  inline ::std::string* release_pseudo();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.LoginResultResponse)
 private:
  inline void set_has_is_accepted();
  inline void clear_has_is_accepted();
  inline void set_has_pseudo();
  inline void clear_has_pseudo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pseudo_;
  bool is_accepted_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static LoginResultResponse* default_instance_;
};
// -------------------------------------------------------------------

class EchoRequest : public ::google::protobuf::Message {
 public:
  EchoRequest();
  virtual ~EchoRequest();
  
  EchoRequest(const EchoRequest& from);
  
  inline EchoRequest& operator=(const EchoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoRequest& default_instance();
  
  void Swap(EchoRequest* other);
  
  // implements Message ----------------------------------------------
  
  EchoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EchoRequest& from);
  void MergeFrom(const EchoRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.EchoRequest)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static EchoRequest* default_instance_;
};
// -------------------------------------------------------------------

class EchoResponse : public ::google::protobuf::Message {
 public:
  EchoResponse();
  virtual ~EchoResponse();
  
  EchoResponse(const EchoResponse& from);
  
  inline EchoResponse& operator=(const EchoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EchoResponse& default_instance();
  
  void Swap(EchoResponse* other);
  
  // implements Message ----------------------------------------------
  
  EchoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EchoResponse& from);
  void MergeFrom(const EchoResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.EchoResponse)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static EchoResponse* default_instance_;
};
// -------------------------------------------------------------------

class RoutedMessageRequest : public ::google::protobuf::Message {
 public:
  RoutedMessageRequest();
  virtual ~RoutedMessageRequest();
  
  RoutedMessageRequest(const RoutedMessageRequest& from);
  
  inline RoutedMessageRequest& operator=(const RoutedMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutedMessageRequest& default_instance();
  
  void Swap(RoutedMessageRequest* other);
  
  // implements Message ----------------------------------------------
  
  RoutedMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoutedMessageRequest& from);
  void MergeFrom(const RoutedMessageRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string recipient = 1;
  inline bool has_recipient() const;
  inline void clear_recipient();
  static const int kRecipientFieldNumber = 1;
  inline const ::std::string& recipient() const;
  inline void set_recipient(const ::std::string& value);
  inline void set_recipient(const char* value);
  inline void set_recipient(const char* value, size_t size);
  inline ::std::string* mutable_recipient();
  inline ::std::string* release_recipient();
  
  // required string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.RoutedMessageRequest)
 private:
  inline void set_has_recipient();
  inline void clear_has_recipient();
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* recipient_;
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static RoutedMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class RoutedMessageResponse : public ::google::protobuf::Message {
 public:
  RoutedMessageResponse();
  virtual ~RoutedMessageResponse();
  
  RoutedMessageResponse(const RoutedMessageResponse& from);
  
  inline RoutedMessageResponse& operator=(const RoutedMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutedMessageResponse& default_instance();
  
  void Swap(RoutedMessageResponse* other);
  
  // implements Message ----------------------------------------------
  
  RoutedMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoutedMessageResponse& from);
  void MergeFrom(const RoutedMessageResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  
  // required string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.RoutedMessageResponse)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sender_;
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static RoutedMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class GroupMessageRequest : public ::google::protobuf::Message {
 public:
  GroupMessageRequest();
  virtual ~GroupMessageRequest();
  
  GroupMessageRequest(const GroupMessageRequest& from);
  
  inline GroupMessageRequest& operator=(const GroupMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMessageRequest& default_instance();
  
  void Swap(GroupMessageRequest* other);
  
  // implements Message ----------------------------------------------
  
  GroupMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupMessageRequest& from);
  void MergeFrom(const GroupMessageRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.GroupMessageRequest)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GroupMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class GroupMessageResponse : public ::google::protobuf::Message {
 public:
  GroupMessageResponse();
  virtual ~GroupMessageResponse();
  
  GroupMessageResponse(const GroupMessageResponse& from);
  
  inline GroupMessageResponse& operator=(const GroupMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMessageResponse& default_instance();
  
  void Swap(GroupMessageResponse* other);
  
  // implements Message ----------------------------------------------
  
  GroupMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupMessageResponse& from);
  void MergeFrom(const GroupMessageResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  
  // required string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.GroupMessageResponse)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sender_;
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GroupMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeToBroadcastQueueRequest : public ::google::protobuf::Message {
 public:
  SubscribeToBroadcastQueueRequest();
  virtual ~SubscribeToBroadcastQueueRequest();
  
  SubscribeToBroadcastQueueRequest(const SubscribeToBroadcastQueueRequest& from);
  
  inline SubscribeToBroadcastQueueRequest& operator=(const SubscribeToBroadcastQueueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeToBroadcastQueueRequest& default_instance();
  
  void Swap(SubscribeToBroadcastQueueRequest* other);
  
  // implements Message ----------------------------------------------
  
  SubscribeToBroadcastQueueRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeToBroadcastQueueRequest& from);
  void MergeFrom(const SubscribeToBroadcastQueueRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string queueName = 1;
  inline int queuename_size() const;
  inline void clear_queuename();
  static const int kQueueNameFieldNumber = 1;
  inline const ::std::string& queuename(int index) const;
  inline ::std::string* mutable_queuename(int index);
  inline void set_queuename(int index, const ::std::string& value);
  inline void set_queuename(int index, const char* value);
  inline void set_queuename(int index, const char* value, size_t size);
  inline ::std::string* add_queuename();
  inline void add_queuename(const ::std::string& value);
  inline void add_queuename(const char* value);
  inline void add_queuename(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& queuename() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_queuename();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.SubscribeToBroadcastQueueRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> queuename_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static SubscribeToBroadcastQueueRequest* default_instance_;
};
// -------------------------------------------------------------------

class BroadcastMessageRequest : public ::google::protobuf::Message {
 public:
  BroadcastMessageRequest();
  virtual ~BroadcastMessageRequest();
  
  BroadcastMessageRequest(const BroadcastMessageRequest& from);
  
  inline BroadcastMessageRequest& operator=(const BroadcastMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastMessageRequest& default_instance();
  
  void Swap(BroadcastMessageRequest* other);
  
  // implements Message ----------------------------------------------
  
  BroadcastMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadcastMessageRequest& from);
  void MergeFrom(const BroadcastMessageRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 messageId = 1;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 1;
  inline ::google::protobuf::uint32 messageid() const;
  inline void set_messageid(::google::protobuf::uint32 value);
  
  // repeated string queueName = 2;
  inline int queuename_size() const;
  inline void clear_queuename();
  static const int kQueueNameFieldNumber = 2;
  inline const ::std::string& queuename(int index) const;
  inline ::std::string* mutable_queuename(int index);
  inline void set_queuename(int index, const ::std::string& value);
  inline void set_queuename(int index, const char* value);
  inline void set_queuename(int index, const char* value, size_t size);
  inline ::std::string* add_queuename();
  inline void add_queuename(const ::std::string& value);
  inline void add_queuename(const char* value);
  inline void add_queuename(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& queuename() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_queuename();
  
  // required string payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const char* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // required string timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.BroadcastMessageRequest)
 private:
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> queuename_;
  ::std::string* payload_;
  ::std::string* timestamp_;
  ::google::protobuf::uint32 messageid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static BroadcastMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class BroadcastMessageResponse : public ::google::protobuf::Message {
 public:
  BroadcastMessageResponse();
  virtual ~BroadcastMessageResponse();
  
  BroadcastMessageResponse(const BroadcastMessageResponse& from);
  
  inline BroadcastMessageResponse& operator=(const BroadcastMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BroadcastMessageResponse& default_instance();
  
  void Swap(BroadcastMessageResponse* other);
  
  // implements Message ----------------------------------------------
  
  BroadcastMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BroadcastMessageResponse& from);
  void MergeFrom(const BroadcastMessageResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  
  // required uint32 messageId = 2;
  inline bool has_messageid() const;
  inline void clear_messageid();
  static const int kMessageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 messageid() const;
  inline void set_messageid(::google::protobuf::uint32 value);
  
  // required string queueName = 3;
  inline bool has_queuename() const;
  inline void clear_queuename();
  static const int kQueueNameFieldNumber = 3;
  inline const ::std::string& queuename() const;
  inline void set_queuename(const ::std::string& value);
  inline void set_queuename(const char* value);
  inline void set_queuename(const char* value, size_t size);
  inline ::std::string* mutable_queuename();
  inline ::std::string* release_queuename();
  
  // required string payload = 4;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 4;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const char* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // required string timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.BroadcastMessageResponse)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_messageid();
  inline void clear_has_messageid();
  inline void set_has_queuename();
  inline void clear_has_queuename();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sender_;
  ::std::string* queuename_;
  ::std::string* payload_;
  ::std::string* timestamp_;
  ::google::protobuf::uint32 messageid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static BroadcastMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class MemTestRequest : public ::google::protobuf::Message {
 public:
  MemTestRequest();
  virtual ~MemTestRequest();
  
  MemTestRequest(const MemTestRequest& from);
  
  inline MemTestRequest& operator=(const MemTestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemTestRequest& default_instance();
  
  void Swap(MemTestRequest* other);
  
  // implements Message ----------------------------------------------
  
  MemTestRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemTestRequest& from);
  void MergeFrom(const MemTestRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // required uint32 target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline ::google::protobuf::uint32 target() const;
  inline void set_target(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.MemTestRequest)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_target();
  inline void clear_has_target();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msg_;
  ::google::protobuf::uint32 target_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static MemTestRequest* default_instance_;
};
// -------------------------------------------------------------------

class MemTestResponse : public ::google::protobuf::Message {
 public:
  MemTestResponse();
  virtual ~MemTestResponse();
  
  MemTestResponse(const MemTestResponse& from);
  
  inline MemTestResponse& operator=(const MemTestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MemTestResponse& default_instance();
  
  void Swap(MemTestResponse* other);
  
  // implements Message ----------------------------------------------
  
  MemTestResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemTestResponse& from);
  void MergeFrom(const MemTestResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  
  // @@protoc_insertion_point(class_scope:testsuitemessages.MemTestResponse)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msg_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static MemTestResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// optional string pseudo = 1;
inline bool LoginRequest::has_pseudo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_pseudo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_pseudo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_pseudo() {
  if (pseudo_ != &::google::protobuf::internal::kEmptyString) {
    pseudo_->clear();
  }
  clear_has_pseudo();
}
inline const ::std::string& LoginRequest::pseudo() const {
  return *pseudo_;
}
inline void LoginRequest::set_pseudo(const ::std::string& value) {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  pseudo_->assign(value);
}
inline void LoginRequest::set_pseudo(const char* value) {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  pseudo_->assign(value);
}
inline void LoginRequest::set_pseudo(const char* value, size_t size) {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  pseudo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_pseudo() {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  return pseudo_;
}
inline ::std::string* LoginRequest::release_pseudo() {
  clear_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pseudo_;
    pseudo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool claimPseudo = 2;
inline bool LoginRequest::has_claimpseudo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_claimpseudo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_claimpseudo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_claimpseudo() {
  claimpseudo_ = false;
  clear_has_claimpseudo();
}
inline bool LoginRequest::claimpseudo() const {
  return claimpseudo_;
}
inline void LoginRequest::set_claimpseudo(bool value) {
  set_has_claimpseudo();
  claimpseudo_ = value;
}

// required string accessKey = 3;
inline bool LoginRequest::has_accesskey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_accesskey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_accesskey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_accesskey() {
  if (accesskey_ != &::google::protobuf::internal::kEmptyString) {
    accesskey_->clear();
  }
  clear_has_accesskey();
}
inline const ::std::string& LoginRequest::accesskey() const {
  return *accesskey_;
}
inline void LoginRequest::set_accesskey(const ::std::string& value) {
  set_has_accesskey();
  if (accesskey_ == &::google::protobuf::internal::kEmptyString) {
    accesskey_ = new ::std::string;
  }
  accesskey_->assign(value);
}
inline void LoginRequest::set_accesskey(const char* value) {
  set_has_accesskey();
  if (accesskey_ == &::google::protobuf::internal::kEmptyString) {
    accesskey_ = new ::std::string;
  }
  accesskey_->assign(value);
}
inline void LoginRequest::set_accesskey(const char* value, size_t size) {
  set_has_accesskey();
  if (accesskey_ == &::google::protobuf::internal::kEmptyString) {
    accesskey_ = new ::std::string;
  }
  accesskey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_accesskey() {
  set_has_accesskey();
  if (accesskey_ == &::google::protobuf::internal::kEmptyString) {
    accesskey_ = new ::std::string;
  }
  return accesskey_;
}
inline ::std::string* LoginRequest::release_accesskey() {
  clear_has_accesskey();
  if (accesskey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accesskey_;
    accesskey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginResultResponse

// required bool is_accepted = 1;
inline bool LoginResultResponse::has_is_accepted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResultResponse::set_has_is_accepted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResultResponse::clear_has_is_accepted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResultResponse::clear_is_accepted() {
  is_accepted_ = false;
  clear_has_is_accepted();
}
inline bool LoginResultResponse::is_accepted() const {
  return is_accepted_;
}
inline void LoginResultResponse::set_is_accepted(bool value) {
  set_has_is_accepted();
  is_accepted_ = value;
}

// required string pseudo = 2;
inline bool LoginResultResponse::has_pseudo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResultResponse::set_has_pseudo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResultResponse::clear_has_pseudo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResultResponse::clear_pseudo() {
  if (pseudo_ != &::google::protobuf::internal::kEmptyString) {
    pseudo_->clear();
  }
  clear_has_pseudo();
}
inline const ::std::string& LoginResultResponse::pseudo() const {
  return *pseudo_;
}
inline void LoginResultResponse::set_pseudo(const ::std::string& value) {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  pseudo_->assign(value);
}
inline void LoginResultResponse::set_pseudo(const char* value) {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  pseudo_->assign(value);
}
inline void LoginResultResponse::set_pseudo(const char* value, size_t size) {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  pseudo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResultResponse::mutable_pseudo() {
  set_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    pseudo_ = new ::std::string;
  }
  return pseudo_;
}
inline ::std::string* LoginResultResponse::release_pseudo() {
  clear_has_pseudo();
  if (pseudo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pseudo_;
    pseudo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// EchoRequest

// required string msg = 1;
inline bool EchoRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EchoRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EchoRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EchoRequest::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& EchoRequest::msg() const {
  return *msg_;
}
inline void EchoRequest::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void EchoRequest::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void EchoRequest::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EchoRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* EchoRequest::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// EchoResponse

// required string msg = 1;
inline bool EchoResponse::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EchoResponse::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EchoResponse::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EchoResponse::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& EchoResponse::msg() const {
  return *msg_;
}
inline void EchoResponse::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void EchoResponse::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void EchoResponse::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EchoResponse::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* EchoResponse::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RoutedMessageRequest

// required string recipient = 1;
inline bool RoutedMessageRequest::has_recipient() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoutedMessageRequest::set_has_recipient() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoutedMessageRequest::clear_has_recipient() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoutedMessageRequest::clear_recipient() {
  if (recipient_ != &::google::protobuf::internal::kEmptyString) {
    recipient_->clear();
  }
  clear_has_recipient();
}
inline const ::std::string& RoutedMessageRequest::recipient() const {
  return *recipient_;
}
inline void RoutedMessageRequest::set_recipient(const ::std::string& value) {
  set_has_recipient();
  if (recipient_ == &::google::protobuf::internal::kEmptyString) {
    recipient_ = new ::std::string;
  }
  recipient_->assign(value);
}
inline void RoutedMessageRequest::set_recipient(const char* value) {
  set_has_recipient();
  if (recipient_ == &::google::protobuf::internal::kEmptyString) {
    recipient_ = new ::std::string;
  }
  recipient_->assign(value);
}
inline void RoutedMessageRequest::set_recipient(const char* value, size_t size) {
  set_has_recipient();
  if (recipient_ == &::google::protobuf::internal::kEmptyString) {
    recipient_ = new ::std::string;
  }
  recipient_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoutedMessageRequest::mutable_recipient() {
  set_has_recipient();
  if (recipient_ == &::google::protobuf::internal::kEmptyString) {
    recipient_ = new ::std::string;
  }
  return recipient_;
}
inline ::std::string* RoutedMessageRequest::release_recipient() {
  clear_has_recipient();
  if (recipient_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recipient_;
    recipient_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string msg = 2;
inline bool RoutedMessageRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoutedMessageRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoutedMessageRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoutedMessageRequest::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& RoutedMessageRequest::msg() const {
  return *msg_;
}
inline void RoutedMessageRequest::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void RoutedMessageRequest::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void RoutedMessageRequest::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoutedMessageRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* RoutedMessageRequest::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RoutedMessageResponse

// required string sender = 1;
inline bool RoutedMessageResponse::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoutedMessageResponse::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoutedMessageResponse::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoutedMessageResponse::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& RoutedMessageResponse::sender() const {
  return *sender_;
}
inline void RoutedMessageResponse::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void RoutedMessageResponse::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void RoutedMessageResponse::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoutedMessageResponse::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* RoutedMessageResponse::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string msg = 2;
inline bool RoutedMessageResponse::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoutedMessageResponse::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoutedMessageResponse::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoutedMessageResponse::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& RoutedMessageResponse::msg() const {
  return *msg_;
}
inline void RoutedMessageResponse::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void RoutedMessageResponse::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void RoutedMessageResponse::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoutedMessageResponse::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* RoutedMessageResponse::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GroupMessageRequest

// required string msg = 1;
inline bool GroupMessageRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMessageRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMessageRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMessageRequest::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& GroupMessageRequest::msg() const {
  return *msg_;
}
inline void GroupMessageRequest::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void GroupMessageRequest::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void GroupMessageRequest::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMessageRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* GroupMessageRequest::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GroupMessageResponse

// required string sender = 1;
inline bool GroupMessageResponse::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMessageResponse::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMessageResponse::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMessageResponse::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& GroupMessageResponse::sender() const {
  return *sender_;
}
inline void GroupMessageResponse::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void GroupMessageResponse::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void GroupMessageResponse::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMessageResponse::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* GroupMessageResponse::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string msg = 2;
inline bool GroupMessageResponse::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMessageResponse::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMessageResponse::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMessageResponse::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& GroupMessageResponse::msg() const {
  return *msg_;
}
inline void GroupMessageResponse::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void GroupMessageResponse::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void GroupMessageResponse::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMessageResponse::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* GroupMessageResponse::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SubscribeToBroadcastQueueRequest

// repeated string queueName = 1;
inline int SubscribeToBroadcastQueueRequest::queuename_size() const {
  return queuename_.size();
}
inline void SubscribeToBroadcastQueueRequest::clear_queuename() {
  queuename_.Clear();
}
inline const ::std::string& SubscribeToBroadcastQueueRequest::queuename(int index) const {
  return queuename_.Get(index);
}
inline ::std::string* SubscribeToBroadcastQueueRequest::mutable_queuename(int index) {
  return queuename_.Mutable(index);
}
inline void SubscribeToBroadcastQueueRequest::set_queuename(int index, const ::std::string& value) {
  queuename_.Mutable(index)->assign(value);
}
inline void SubscribeToBroadcastQueueRequest::set_queuename(int index, const char* value) {
  queuename_.Mutable(index)->assign(value);
}
inline void SubscribeToBroadcastQueueRequest::set_queuename(int index, const char* value, size_t size) {
  queuename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeToBroadcastQueueRequest::add_queuename() {
  return queuename_.Add();
}
inline void SubscribeToBroadcastQueueRequest::add_queuename(const ::std::string& value) {
  queuename_.Add()->assign(value);
}
inline void SubscribeToBroadcastQueueRequest::add_queuename(const char* value) {
  queuename_.Add()->assign(value);
}
inline void SubscribeToBroadcastQueueRequest::add_queuename(const char* value, size_t size) {
  queuename_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SubscribeToBroadcastQueueRequest::queuename() const {
  return queuename_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SubscribeToBroadcastQueueRequest::mutable_queuename() {
  return &queuename_;
}

// -------------------------------------------------------------------

// BroadcastMessageRequest

// required uint32 messageId = 1;
inline bool BroadcastMessageRequest::has_messageid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastMessageRequest::set_has_messageid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastMessageRequest::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastMessageRequest::clear_messageid() {
  messageid_ = 0u;
  clear_has_messageid();
}
inline ::google::protobuf::uint32 BroadcastMessageRequest::messageid() const {
  return messageid_;
}
inline void BroadcastMessageRequest::set_messageid(::google::protobuf::uint32 value) {
  set_has_messageid();
  messageid_ = value;
}

// repeated string queueName = 2;
inline int BroadcastMessageRequest::queuename_size() const {
  return queuename_.size();
}
inline void BroadcastMessageRequest::clear_queuename() {
  queuename_.Clear();
}
inline const ::std::string& BroadcastMessageRequest::queuename(int index) const {
  return queuename_.Get(index);
}
inline ::std::string* BroadcastMessageRequest::mutable_queuename(int index) {
  return queuename_.Mutable(index);
}
inline void BroadcastMessageRequest::set_queuename(int index, const ::std::string& value) {
  queuename_.Mutable(index)->assign(value);
}
inline void BroadcastMessageRequest::set_queuename(int index, const char* value) {
  queuename_.Mutable(index)->assign(value);
}
inline void BroadcastMessageRequest::set_queuename(int index, const char* value, size_t size) {
  queuename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastMessageRequest::add_queuename() {
  return queuename_.Add();
}
inline void BroadcastMessageRequest::add_queuename(const ::std::string& value) {
  queuename_.Add()->assign(value);
}
inline void BroadcastMessageRequest::add_queuename(const char* value) {
  queuename_.Add()->assign(value);
}
inline void BroadcastMessageRequest::add_queuename(const char* value, size_t size) {
  queuename_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BroadcastMessageRequest::queuename() const {
  return queuename_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BroadcastMessageRequest::mutable_queuename() {
  return &queuename_;
}

// required string payload = 3;
inline bool BroadcastMessageRequest::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BroadcastMessageRequest::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BroadcastMessageRequest::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BroadcastMessageRequest::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& BroadcastMessageRequest::payload() const {
  return *payload_;
}
inline void BroadcastMessageRequest::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void BroadcastMessageRequest::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void BroadcastMessageRequest::set_payload(const char* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastMessageRequest::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* BroadcastMessageRequest::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string timestamp = 4;
inline bool BroadcastMessageRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BroadcastMessageRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BroadcastMessageRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BroadcastMessageRequest::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& BroadcastMessageRequest::timestamp() const {
  return *timestamp_;
}
inline void BroadcastMessageRequest::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void BroadcastMessageRequest::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void BroadcastMessageRequest::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastMessageRequest::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* BroadcastMessageRequest::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BroadcastMessageResponse

// required string sender = 1;
inline bool BroadcastMessageResponse::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BroadcastMessageResponse::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BroadcastMessageResponse::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BroadcastMessageResponse::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& BroadcastMessageResponse::sender() const {
  return *sender_;
}
inline void BroadcastMessageResponse::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void BroadcastMessageResponse::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void BroadcastMessageResponse::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastMessageResponse::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* BroadcastMessageResponse::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 messageId = 2;
inline bool BroadcastMessageResponse::has_messageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BroadcastMessageResponse::set_has_messageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BroadcastMessageResponse::clear_has_messageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BroadcastMessageResponse::clear_messageid() {
  messageid_ = 0u;
  clear_has_messageid();
}
inline ::google::protobuf::uint32 BroadcastMessageResponse::messageid() const {
  return messageid_;
}
inline void BroadcastMessageResponse::set_messageid(::google::protobuf::uint32 value) {
  set_has_messageid();
  messageid_ = value;
}

// required string queueName = 3;
inline bool BroadcastMessageResponse::has_queuename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BroadcastMessageResponse::set_has_queuename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BroadcastMessageResponse::clear_has_queuename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BroadcastMessageResponse::clear_queuename() {
  if (queuename_ != &::google::protobuf::internal::kEmptyString) {
    queuename_->clear();
  }
  clear_has_queuename();
}
inline const ::std::string& BroadcastMessageResponse::queuename() const {
  return *queuename_;
}
inline void BroadcastMessageResponse::set_queuename(const ::std::string& value) {
  set_has_queuename();
  if (queuename_ == &::google::protobuf::internal::kEmptyString) {
    queuename_ = new ::std::string;
  }
  queuename_->assign(value);
}
inline void BroadcastMessageResponse::set_queuename(const char* value) {
  set_has_queuename();
  if (queuename_ == &::google::protobuf::internal::kEmptyString) {
    queuename_ = new ::std::string;
  }
  queuename_->assign(value);
}
inline void BroadcastMessageResponse::set_queuename(const char* value, size_t size) {
  set_has_queuename();
  if (queuename_ == &::google::protobuf::internal::kEmptyString) {
    queuename_ = new ::std::string;
  }
  queuename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastMessageResponse::mutable_queuename() {
  set_has_queuename();
  if (queuename_ == &::google::protobuf::internal::kEmptyString) {
    queuename_ = new ::std::string;
  }
  return queuename_;
}
inline ::std::string* BroadcastMessageResponse::release_queuename() {
  clear_has_queuename();
  if (queuename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = queuename_;
    queuename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string payload = 4;
inline bool BroadcastMessageResponse::has_payload() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BroadcastMessageResponse::set_has_payload() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BroadcastMessageResponse::clear_has_payload() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BroadcastMessageResponse::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& BroadcastMessageResponse::payload() const {
  return *payload_;
}
inline void BroadcastMessageResponse::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void BroadcastMessageResponse::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void BroadcastMessageResponse::set_payload(const char* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastMessageResponse::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* BroadcastMessageResponse::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string timestamp = 5;
inline bool BroadcastMessageResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BroadcastMessageResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BroadcastMessageResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BroadcastMessageResponse::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::kEmptyString) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& BroadcastMessageResponse::timestamp() const {
  return *timestamp_;
}
inline void BroadcastMessageResponse::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void BroadcastMessageResponse::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
}
inline void BroadcastMessageResponse::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BroadcastMessageResponse::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    timestamp_ = new ::std::string;
  }
  return timestamp_;
}
inline ::std::string* BroadcastMessageResponse::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MemTestRequest

// required string msg = 1;
inline bool MemTestRequest::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemTestRequest::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemTestRequest::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemTestRequest::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& MemTestRequest::msg() const {
  return *msg_;
}
inline void MemTestRequest::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MemTestRequest::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MemTestRequest::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemTestRequest::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* MemTestRequest::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 target = 2;
inline bool MemTestRequest::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemTestRequest::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemTestRequest::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemTestRequest::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 MemTestRequest::target() const {
  return target_;
}
inline void MemTestRequest::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
}

// -------------------------------------------------------------------

// MemTestResponse

// required string msg = 1;
inline bool MemTestResponse::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemTestResponse::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemTestResponse::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemTestResponse::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& MemTestResponse::msg() const {
  return *msg_;
}
inline void MemTestResponse::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MemTestResponse::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MemTestResponse::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemTestResponse::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* MemTestResponse::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace testsuitemessages

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
